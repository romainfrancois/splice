#' @importFrom rlang abort sym enquo

manip_all <- function(...) abort("")
manip_if <- function(...) abort("")
manip_at <- function(...) abort("")

.onLoad <- function(...) {
  dplyr <- asNamespace("dplyr")
  manip_all <<- dplyr$manip_all
  manip_if  <<- dplyr$manip_if
  manip_at  <<- dplyr$manip_at
}

.splice_context <- function(...) {
  calls <- sys.calls()
  frames <- sys.frames()
  n <- length(frames)

  if( !identical(calls[[n-2]][[1]], sym("quos")) || !frames[[n-3L]][[".Generic"]] %in% c("summarise", "mutate") || !identical(frames[[n-3L]][[".GenericDefEnv"]], asNamespace("dplyr")) ) {
    abort("not called correctly")
  }

  list(.data = frames[[n-3]]$.data, .env = frames[[n-3L]], ...)
}

#' Splice utilities
#'
#' The helpers `all_()`, `if_()` and `at_()` are meant to be spliced
#' into calls to `dplyr::summarise()` or `dplyr::mutate()`
#'
#' @param .funs A function `fun`, a quosure style lambda `~ fun(.)` or a list of either form.
#' @param .vars A list of columns generated by [dplyr::vars()],
#'   a character vector of column names, a numeric vector of column
#'   positions, or `NULL`.
#' @param .predicate A predicate function to be applied to the columns
#'   or a logical vector. The variables for which `.predicate` is or
#'   returns `TRUE` are selected. This argument is passed to
#'   [rlang::as_function()] and thus supports quosure-style lambda
#'   functions and strings representing function names.
#' @param ... Additional arguments for the function calls in
#'   `.funs`. These are evaluated only once, with [tidy
#'   dots][rlang::tidy-dots] support.
#'
#' @export
#' @examples
#' library(dplyr, warn.conflicts = FALSE)
#' tbl <- iris %>%
#'   group_by(Species)
#'
#' # all_
#' tbl %>%
#'   summarise(n = n(), !!!all_(mean))
#'
#' tbl %>%
#'   summarise(n = n(), !!!all_(~mean(.)))
#'
#' tbl %>%
#'   summarise(n = n(), !!!all_(list(mean = mean, median = median)))
#'
#' # if_
#' iris %>%
#'   summarise(n = n(), !!!if_(is.numeric, mean))
#'
#' # at_
#' iris %>%
#'   summarise(n = n(), !!!at_(vars(starts_with("Sepal")), mean))
all_ <- function(.funs, ...) {
  context <- .splice_context()
  manip_all(context$.data, .funs, enquo(.funs), context$.env, ...)
}

#' @rdname all_
#' @export
if_ <- function(.predicate, .funs, ...) {
  context <- .splice_context()
  manip_if(context$.data, .predicate, .funs, enquo(.funs), context$.env, ...)
}

#' @rdname all_
#' @export
at_ <- function(.vars, .funs, ...){
  context <- .splice_context()
  manip_at(context$.data, .vars, .funs, enquo(.funs), context$.env, ...)
}
